---
name: rust-auto-fixer
description: Verifies and auto-fixes Rust code by compiling it and analyzing errors. Trigger this skill when the user provides Rust code that needs validation, or when previously generated Rust code fails to compile.
---

# Rust Auto Fixer

## Overview

This skill provides an automated loop for fixing Rust compilation errors. It takes a Rust code snippet, runs it through a real compiler (`cargo check`), analyzes the output, and iteratively applies fixes.

It is particularly useful for:
1.  Validating code generated by the Agent.
2.  Fixing tricky ownership and borrow checker errors (E0382, E0502).
3.  Ensuring dependencies are correctly handled.

## Workflow

1.  **Review Input**: Analyze the provided code and context.
2.  **Check Code**: Call `check_rust_code`.
    -   This tool automatically attempts to detect dependencies based on `use` statements.
3.  **Analyze Results**:
23→    -   **SUCCESS**: If the tool returns "SUCCESS" followed by code, the code is valid.
24→        -   **IMPORTANT**: The tool returns the `rustfmt` formatted code after "SUCCESS".
25→        -   You **MUST** use this formatted code in your final `<code_block>`.
26→    -   **ERRORS**: If errors are returned, analyze them using the strategies in [Rust Fix Strategies](references/rust_fix_strategies.md).
27→4.  **Fix & Verify (Loop Constraint)**:
26→    -   Apply the fix (e.g., adding `.clone()`, changing lifetimes, fixing types).
27→    -   **CRITICAL**: You have a maximum budget of **3 attempts**.
28→    -   If the code still fails after 3 fixes, STOP and output the last error with a note: "Max attempts reached."
29→    -   (Optional) Re-run `check_rust_code` to verify.
30→5.  **Output**: Return the final result.

## Tools

### check_rust_code

Located at `scripts/cargo_runner.py`.
-   **Auto-Dependency Detection**: Scans for `use crate::module` patterns and adds them to `Cargo.toml` with version `*`.
-   **JSON Output**: Returns parsed compiler errors for easy analysis.
-   **Formatting**: Automatically runs `rustfmt` on success and returns the formatted code.
-   **Caching**: Uses a persistent build directory to speed up compilation.

**Usage**:
1.  Save the Rust code snippet to a temporary file (e.g., `temp.rs`).
2.  Run the python script with the file path as an argument:
    ```bash
    python scripts/cargo_runner.py temp.rs
    ```
3.  Read the output. It will be "SUCCESS" or a list of error messages.

## Input Schema

```xml
<input_schema>
  <code_snippet>
  // The Rust code.
  // Dependencies are auto-detected from 'use' statements.
  // For macros like #[macro_use] extern crate ..., detection might fail.
  // Note: For best results, please include use statements for external crates, or mention them in the context.
  </code_snippet>
  <context>Optional context</context>
</input_schema>
```

## Output Schema

```xml
<fixed_result> 
  <original_errors>Summary of errors found</original_errors> 
  <explanation>Explanation of the fix applied</explanation> 
  <code_block>The fixed Rust code</code_block>
</fixed_result>
```
